{% extends 'base.html' %}

{% block title %}Combined Strategy Charts - Zerodha Automation{% endblock %}

{% block extra_css %}
<style>
    .chart-container {
        background: rgba(13, 17, 23, 0.95);
        border: 1px solid #30363d;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
    }
    
    .chart-container:hover {
        border-color: #58a6ff;
        box-shadow: 0 12px 40px rgba(88, 166, 255, 0.2);
        transform: translateY(-2px);
    }
    
    .chart-title {
        color: #58a6ff;
        font-weight: 600;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .chart-controls {
        background: rgba(22, 27, 34, 0.95);
        border: 1px solid #30363d;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 25px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    
    .chart-controls-panel {
        background: rgba(22, 27, 34, 0.9);
        border: 1px solid #30363d;
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 20px;
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
    }
    
    .chart-controls-panel label {
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
        user-select: none;
        background: rgba(88, 166, 255, 0.1);
        border: 1px solid #58a6ff;
        color: #58a6ff;
        border-radius: 6px;
        padding: 8px 12px;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        font-weight: 500;
    }
    
    .chart-controls-panel label:hover,
    .chart-controls-panel label.active {
        background: #58a6ff;
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(88, 166, 255, 0.3);
    }
    
    .chart-controls-panel input[type="checkbox"] {
        margin-right: 5px;
    }
    
    .combined-chart {
        min-height: 80vh;
    }
    
    .combined-chart #combinedChart {
        height: calc(80vh - 120px) !important;
    }
    
    .fullscreen-btn {
        background: rgba(88, 166, 255, 0.1);
        border: 1px solid #58a6ff;
        color: #58a6ff;
        border-radius: 8px;
        padding: 5px 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.8rem;
    }
    
    .fullscreen-btn:hover {
        background: #58a6ff;
        color: #ffffff;
    }
    
    .chart-wrapper {
        position: relative;
        min-height: 500px;
        width: 100%; /* Match the width of the select bucket list container */
        display: flex;
        justify-content: center; /* Center the chart horizontally */
    }
    
    .chart-wrapper.fullscreen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 9999;
        background: rgba(13, 17, 23, 0.98);
        backdrop-filter: blur(15px);
        padding: 20px;
    }
    
    .chart-wrapper.fullscreen .chart-container {
        height: calc(100vh - 40px);
        margin: 0;
    }
    
    .loading-spinner {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 200px;
        flex-direction: column;
        color: #58a6ff;
    }
    
    .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #30363d;
        border-top: 4px solid #58a6ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .chart-error {
        background: rgba(218, 54, 51, 0.1);
        border: 1px solid #da3633;
        color: #ff7b72;
        border-radius: 10px;
        padding: 20px;
        text-align: center;
        margin: 20px 0;
    }
    
    .chart-empty {
        background: rgba(139, 148, 158, 0.1);
        border: 1px solid #8b949e;
        color: #8b949e;
        border-radius: 10px;
        padding: 20px;
        text-align: center;
        margin: 20px 0;
    }
    
    .stats-bar {
        background: rgba(22, 27, 34, 0.8);
        border: 1px solid #30363d;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-around;
        flex-wrap: wrap;
        gap: 15px;
    }
    
    .stat-item {
        text-align: center;
        color: #c9d1d9;
    }
    
    .stat-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #58a6ff;
        display: block;
    }
    
    .stat-label {
        font-size: 0.9rem;
        color: #8b949e;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid px-4" id="mainContainer">
    <!-- Header Section -->
    <div class="row mb-4" id="headerSection">
        <div class="col">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <h2><i class="fas fa-chart-area me-2"></i>Combined Strategy Analysis</h2>
                    <p class="text-muted">Unified view of OHLC data, trading signals, and technical indicators</p>
                </div>
                <div class="d-flex gap-2">
                    <a href="{% url 'strategy_view' %}" class="btn btn-outline-secondary">
                        <i class="fas fa-arrow-left me-2"></i>Back to Strategy
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart Controls -->
    <div class="chart-controls" id="chartControls">
        <div class="row">
            <div class="col-lg-8">
                <label class="form-label">Select Backtest Result:</label>
                <select class="form-select" id="backtestSelect">
                    <option value="">-- Select a backtest result --</option>
                    {% for backtest in backtests %}
                    <option value="{{ backtest.id }}" data-symbol="{{ backtest.symbol }}">
                        {{ backtest.symbol }} - {{ backtest.strategy.name }} ({{ backtest.from_date }} to {{ backtest.to_date }})
                    </option>
                    {% endfor %}
                </select>
            </div>
            <div class="col-lg-4 d-flex align-items-end">
                <button class="btn btn-primary w-100" onclick="loadCharts(); enableChartOnlyMode();">
                    <i class="fas fa-chart-bar me-2"></i>Load Combined Chart
                </button>
            </div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loadingIndicator" class="loading-spinner" style="display: none;">
        <div class="spinner"></div>
        <p>Loading combined chart data...</p>
    </div>

    <!-- Statistics Bar -->
    <div id="statsBar" class="stats-bar" style="display: none;">
        <div class="stat-item">
            <span class="stat-value" id="totalTrades">-</span>
            <span class="stat-label">Total Trades</span>
        </div>
        <div class="stat-item">
            <span class="stat-value" id="profitTrades">-</span>
            <span class="stat-label">Profit Trades</span>
        </div>
        <div class="stat-item">
            <span class="stat-value" id="lossTrades">-</span>
            <span class="stat-label">Loss Trades</span>
        </div>
        <div class="stat-item">
            <span class="stat-value" id="winRate">-</span>
            <span class="stat-label">Win Rate</span>
        </div>
        <div class="stat-item">
            <span class="stat-value" id="totalPnL">-</span>
            <span class="stat-label">Total P&L</span>
        </div>
    </div>

    <!-- Combined Chart Section -->
    <div id="chartsSection" style="display: none;">
        <div class="chart-wrapper combined-chart" id="combinedWrapper">
            <div class="chart-container">
                <h5 class="chart-title">
                
                    <button class="fullscreen-btn" onclick="toggleFullscreen('combinedWrapper')">
                        <i class="fas fa-expand"></i> Fullscreen
                    </button>
                </h5>
                <div class="chart-controls-panel">
                    <label class="active" id="toggleCandlestick">
                        <input type="checkbox" checked onchange="toggleTrace('candlestick')"> OHLC Candlesticks
                    </label>
                    <label class="active" id="toggleSignals">
                        <input type="checkbox" checked onchange="toggleTrace('signals')"> Buy/Sell Signals
                    </label>
                    <label class="active" id="toggleMA">
                        <input type="checkbox" checked onchange="toggleTrace('ma')"> Moving Average
                    </label>
                    <label class="active" id="toggleMACD">
                        <input type="checkbox" checked onchange="toggleTrace('macd')"> MACD Indicators
                    </label>
                </div>
                <div id="combinedChart" style="height: calc(80vh - 120px);"></div>
            </div>
        </div>
    </div>

    <!-- No Data Message -->
    <div id="noDataMessage" class="text-center py-5" style="display: none;">
        <i class="fas fa-chart-area fa-3x text-muted mb-3"></i>
        <h5>No Chart Data Available</h5>
        <p class="text-muted">Please execute a strategy first to generate chart data</p>
        <a href="{% url 'strategy_view' %}" class="btn btn-primary">
            <i class="fas fa-robot me-2"></i>Go to Strategy
        </a>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Plotly.js for interactive charts -->
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<script>
let currentChartData = null;

// Helper function to check if a timestamp is within trading hours
function isTradingHour(dateString) {
    const date = new Date(dateString);
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const timeInMinutes = hours * 60 + minutes;
    
    const marketOpenMinutes = 9 * 60 + 15;  // 9:15 AM
    const marketCloseMinutes = 15 * 60 + 30; // 3:30 PM
    
    const dayOfWeek = date.getDay();
    const isWeekday = dayOfWeek >= 1 && dayOfWeek <= 5;
    
    return isWeekday && timeInMinutes >= marketOpenMinutes && timeInMinutes <= marketCloseMinutes;
}

// Helper function to format datetime for display
function formatDateTime(dateString) {
    const date = new Date(dateString);
    const options = {
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    };
    return date.toLocaleDateString('en-US', options);
}

// Helper function to create index-to-date mapping for signals
function mapSignalsToIndices(signals, ohlcData) {
    return signals.map(signal => {
        const signalTime = new Date(signal.timestamp);
        let closestIndex = -1;
        let minTimeDiff = Infinity;
        
        ohlcData.forEach((ohlc, index) => {
            if (isTradingHour(ohlc.date)) {
                const ohlcTime = new Date(ohlc.date);
                const timeDiff = Math.abs(signalTime - ohlcTime);
                if (timeDiff < minTimeDiff) {
                    minTimeDiff = timeDiff;
                    closestIndex = index;
                }
            }
        });
        
        return {
            ...signal,
            mappedIndex: closestIndex
        };
    }).filter(signal => signal.mappedIndex !== -1);
}

function loadCharts() {
    const backtestSelect = document.getElementById('backtestSelect');
    const selectedOption = backtestSelect.options[backtestSelect.selectedIndex];
    
    if (!selectedOption.value) {
        alert('Please select a backtest result');
        return;
    }
    
    const backtestId = selectedOption.value;
    
    // Show loading state
    document.getElementById('chartsSection').style.display = 'none';
    document.getElementById('noDataMessage').style.display = 'none';
    document.getElementById('statsBar').style.display = 'none';
    document.getElementById('loadingIndicator').style.display = 'flex';
    
    // Fetch chart data
    fetch(`/api/chart-data/${backtestId}/`)
        .then(response => {
            console.log('Response received:', response.status, response.statusText);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Chart data received:', data);
            document.getElementById('loadingIndicator').style.display = 'none';
            
            if (data.success) {
                const hasValidOhlc = data.ohlc_data && data.ohlc_data.length > 0;
                const hasValidSignals = data.signals && data.signals.length > 0;
                const hasValidIndicators = data.indicators && 
                    ((data.indicators.macd && data.indicators.macd.length > 0) ||
                     (data.indicators.ma && data.indicators.ma.length > 0));
                
                if (!hasValidOhlc && !hasValidSignals && !hasValidIndicators) {
                    document.getElementById('noDataMessage').style.display = 'block';
                    return;
                }
                
                currentChartData = data;
                
                if (hasValidOhlc || hasValidSignals) {
                    updateStatsBar(data);
                    document.getElementById('statsBar').style.display = 'flex';
                }
                
                renderCombinedChart(data);
                document.getElementById('chartsSection').style.display = 'block';
                
            } else {
                console.error('API returned error:', data.message);
                document.getElementById('noDataMessage').style.display = 'block';
                alert('Error loading chart data: ' + (data.message || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Network Error:', error);
            document.getElementById('loadingIndicator').style.display = 'none';
            document.getElementById('noDataMessage').style.display = 'block';
            alert('Network error occurred while loading chart data. Please check your connection and try again.');
        });
}

function updateStatsBar(data) {
    const signals = data.signals || [];
    const buySignals = signals.filter(s => s.signal_type === 'BUY').length;
    const sellSignals = signals.filter(s => s.signal_type === 'SELL').length;
    const totalTrades = Math.min(buySignals, sellSignals);
    
    let totalPnL = 0;
    let profitTrades = 0;
    let lossTrades = 0;
    
    const buys = signals.filter(s => s.signal_type === 'BUY').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
    const sells = signals.filter(s => s.signal_type === 'SELL').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
    
    for (let i = 0; i < Math.min(buys.length, sells.length); i++) {
        const buyPrice = buys[i].price;
        const sellPrice = sells[i].price;
        const pnl = sellPrice - buyPrice;
        totalPnL += pnl;
        
        if (pnl > 0) profitTrades++;
        else lossTrades++;
    }
    
    const winRate = totalTrades > 0 ? ((profitTrades / totalTrades) * 100).toFixed(1) : 0;
    
    document.getElementById('totalTrades').textContent = totalTrades;
    document.getElementById('profitTrades').textContent = profitTrades;
    document.getElementById('lossTrades').textContent = lossTrades;
    document.getElementById('winRate').textContent = winRate + '%';
    document.getElementById('totalPnL').textContent = '₹' + totalPnL.toFixed(2);
    
    const pnlElement = document.getElementById('totalPnL');
    pnlElement.style.color = totalPnL >= 0 ? '#7ee787' : '#ff7b72';
}

function renderCombinedChart(data) {
    const { ohlc_data, signals, indicators } = data;
    
    // Filter and validate OHLC data for trading hours only
    const validOhlcData = ohlc_data.filter(d => 
        d && d.date && 
        d.open != null && d.high != null && d.low != null && d.close != null &&
        !isNaN(d.open) && !isNaN(d.high) && !isNaN(d.low) && !isNaN(d.close) &&
        d.open > 0 && d.high > 0 && d.low > 0 && d.close > 0 &&
        isTradingHour(d.date)
    );
    
    console.log(`Combined Chart - OHLC: ${validOhlcData.length}, Signals: ${signals.length}`);
    
    if (validOhlcData.length === 0) {
        document.getElementById('combinedChart').innerHTML = '<div class="chart-empty"><i class="fas fa-chart-area"></i><br>No valid data available for combined chart</div>';
        return;
    }

    const traces = [];
    const continuousIndex = validOhlcData.map((d, index) => index);
    
    // 1. OHLC Candlestick Chart
    const candlestickTrace = {
        x: continuousIndex,
        close: validOhlcData.map(d => d.close),
        decreasing: {line: {color: '#ff7b72'}},
        high: validOhlcData.map(d => d.high),
        increasing: {line: {color: '#7ee787'}},
        line: {color: 'rgba(31,119,180,1)'},
        low: validOhlcData.map(d => d.low),
        open: validOhlcData.map(d => d.open),
        type: 'candlestick',
        name: 'OHLC',
        yaxis: 'y',
        visible: true,
        legendgroup: 'price',
        text: validOhlcData.map(d => formatDateTime(d.date)),
        hovertemplate: '<b>%{text}</b><br>' +
                      'Open: ₹%{open:.2f}<br>' +
                      'High: ₹%{high:.2f}<br>' +
                      'Low: ₹%{low:.2f}<br>' +
                      'Close: ₹%{close:.2f}<extra></extra>'
    };
    traces.push(candlestickTrace);

    // 2. Buy/Sell Signals
    const validSignals = signals.filter(s => 
        s && s.timestamp && s.price != null && !isNaN(s.price) && s.signal_type && s.price > 0
    );
    
    if (validSignals.length > 0) {
        const mappedSignals = mapSignalsToIndices(validSignals, validOhlcData);
        
        // Buy signals
        const buySignals = mappedSignals.filter(s => s.signal_type === 'BUY');
        if (buySignals.length > 0) {
            traces.push({
                x: buySignals.map(s => s.mappedIndex),
                y: buySignals.map(s => s.price),
                type: 'scatter',
                mode: 'markers',
                name: 'Buy Signals',
                yaxis: 'y',
                visible: true,
                legendgroup: 'signals',
                marker: {
                    color: '#7ee787',
                    size: 12,
                    symbol: 'triangle-up',
                    line: { color: '#238636', width: 2 }
                },
                text: buySignals.map(s => formatDateTime(s.timestamp)),
                hovertemplate: '<b>Buy Signal</b><br>Date: %{text}<br>Price: ₹%{y:.2f}<extra></extra>'
            });
        }

        // Sell signals
        const sellSignals = mappedSignals.filter(s => s.signal_type === 'SELL');
        if (sellSignals.length > 0) {
            traces.push({
                x: sellSignals.map(s => s.mappedIndex),
                y: sellSignals.map(s => s.price),
                type: 'scatter',
                mode: 'markers',
                name: 'Sell Signals',
                yaxis: 'y',
                visible: true,
                legendgroup: 'signals',
                marker: {
                    color: '#ff7b72',
                    size: 12,
                    symbol: 'triangle-down',
                    line: { color: '#da3633', width: 2 }
                },
                text: sellSignals.map(s => formatDateTime(s.timestamp)),
                hovertemplate: '<b>Sell Signal</b><br>Date: %{text}<br>Price: ₹%{y:.2f}<extra></extra>'
            });
        }
    }

    // 3. Moving Average
    if (indicators.ma && indicators.ma.length > 0) {
        const validMaData = indicators.ma.filter(d => 
            d && d.date && d.value != null && !isNaN(d.value) && isTradingHour(d.date)
        );

        if (validMaData.length > 0) {
            const maIndices = validMaData.map((d, index) => index);
            traces.push({
                x: maIndices,
                y: validMaData.map(d => d.value),
                type: 'scatter',
                mode: 'lines',
                name: 'Moving Average (5)',
                yaxis: 'y',
                visible: true,
                legendgroup: 'ma',
                line: {color: '#2ea043', width: 2, shape: 'linear'},
                connectgaps: true,
                text: validMaData.map(d => formatDateTime(d.date)),
                hovertemplate: '<b>MA(5)</b><br>Date: %{text}<br>Price: ₹%{y:.2f}<extra></extra>'
            });
        }
    }

    // 4. MACD Indicators (on secondary y-axis)
    if (indicators.macd && indicators.macd.length > 0) {
        const validMacdData = indicators.macd.filter(d => 
            d && d.date && 
            d.macd != null && !isNaN(d.macd) &&
            d.signal != null && !isNaN(d.signal) &&
            d.histogram != null && !isNaN(d.histogram) &&
            isTradingHour(d.date)
        );

        if (validMacdData.length > 0) {
            const macdIndices = validMacdData.map((d, index) => index);

            // MACD Line
            traces.push({
                x: macdIndices,
                y: validMacdData.map(d => d.macd),
                type: 'scatter',
                mode: 'lines',
                name: 'MACD',
                yaxis: 'y2',
                visible: true,
                legendgroup: 'macd',
                line: {color: '#58a6ff', width: 2, shape: 'linear'},
                connectgaps: true,
                text: validMacdData.map(d => formatDateTime(d.date)),
                hovertemplate: '<b>MACD</b><br>Date: %{text}<br>Value: %{y:.4f}<extra></extra>'
            });

            // MACD Signal Line
            traces.push({
                x: macdIndices,
                y: validMacdData.map(d => d.signal),
                type: 'scatter',
                mode: 'lines',
                name: 'MACD Signal',
                yaxis: 'y2',
                visible: true,
                legendgroup: 'macd',
                line: {color: '#f7cc47', width: 2, shape: 'linear'},
                connectgaps: true,
                text: validMacdData.map(d => formatDateTime(d.date)),
                hovertemplate: '<b>MACD Signal</b><br>Date: %{text}<br>Value: %{y:.4f}<extra></extra>'
            });

            // MACD Histogram
            traces.push({
                x: macdIndices,
                y: validMacdData.map(d => d.histogram),
                type: 'bar',
                name: 'MACD Histogram',
                yaxis: 'y2',
                visible: true,
                legendgroup: 'macd',
                marker: {
                    color: validMacdData.map(d => d.histogram >= 0 ? '#7ee787' : '#ff7b72'),
                    opacity: 0.5,
                    line: {width: 0}
                },
                text: validMacdData.map(d => formatDateTime(d.date)),
                hovertemplate: '<b>MACD Histogram</b><br>Date: %{text}<br>Value: %{y:.4f}<extra></extra>'
            });
        }
    }

    // Calculate price ranges
    const allPrices = validOhlcData.flatMap(d => [d.open, d.high, d.low, d.close]);
    if (validSignals.length > 0) {
        allPrices.push(...validSignals.map(s => s.price));
    }
    if (indicators.ma && indicators.ma.length > 0) {
        const maValues = indicators.ma.map(d => d.value).filter(v => v != null && !isNaN(v));
        allPrices.push(...maValues);
    }
    
    const minPrice = Math.min(...allPrices);
    const maxPrice = Math.max(...allPrices);
    const priceRange = maxPrice - minPrice;
    const pricePadding = priceRange * 0.05;

    // Calculate MACD range
    let macdRange = [0, 0];
    if (indicators.macd && indicators.macd.length > 0) {
        const macdValues = indicators.macd.flatMap(d => [d.macd, d.signal, d.histogram]).filter(v => v != null && !isNaN(v));
        if (macdValues.length > 0) {
            macdRange = [Math.min(...macdValues), Math.max(...macdValues)];
            const rangePadding = (macdRange[1] - macdRange[0]) * 0.1;
            macdRange = [macdRange[0] - rangePadding, macdRange[1] + rangePadding];
        }
    }

    // Create custom tick labels for x-axis
    const tickvals = [];
    const ticktext = [];
    const totalPoints = validOhlcData.length;
    const tickInterval = Math.max(1, Math.floor(totalPoints / 10));
    
    for (let i = 0; i < totalPoints; i += tickInterval) {
        tickvals.push(i);
        ticktext.push(formatDateTime(validOhlcData[i].date));
    }

    const layout = {
        title: '',
        dragmode: 'zoom',
        margin: {
            r: 80,
            t: 20,
            b: 80,
            l: 80
        },
        xaxis: {
            title: 'Trading Sessions (Non-trading hours excluded)',
            tickvals: tickvals,
            ticktext: ticktext,
            tickangle: -45,
            gridcolor: '#30363d',
            color: '#c9d1d9',
            tickfont: { size: 10 },
            spikethickness: 2,
            spikecolor: '#58a6ff',
            spikemode: 'across',
            spikesnap: 'cursor'
        },
        yaxis: {
            domain: [0.3, 1], // Upper 70% for price data
            title: 'Price (₹)',
            range: [minPrice - pricePadding, maxPrice + pricePadding],
            gridcolor: '#30363d',
            color: '#c9d1d9',
            tickfont: { size: 11 },
            spikethickness: 2,
            spikecolor: '#58a6ff',
            spikemode: 'across',
            spikesnap: 'cursor'
        },
        yaxis2: {
            domain: [0, 0.25], // Lower 25% for MACD
            title: 'MACD',
            range: macdRange[0] !== macdRange[1] ? macdRange : [-1, 1],
            gridcolor: '#30363d',
            color: '#c9d1d9',
            tickfont: { size: 10 },
            zeroline: true,
            zerolinecolor: '#58a6ff',
            zerolinewidth: 1
        },
        plot_bgcolor: 'rgba(13, 17, 23, 0.8)',
        paper_bgcolor: 'rgba(13, 17, 23, 0.8)',
        font: {
            color: '#c9d1d9',
            family: 'Arial, sans-serif',
            size: 11
        },
        legend: {
            bgcolor: 'rgba(13, 17, 23, 0.9)',
            bordercolor: '#30363d',
            borderwidth: 1,
            font: { size: 10 },
            x: 0.02,
            y: 0.98
        },
        hovermode: 'x unified'
    };

    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
        displaylogo: false,
        scrollZoom: true
    };

    Plotly.newPlot('combinedChart', traces, layout, config);
}

// Function to toggle trace visibility
function toggleTrace(traceType) {
    const chartDiv = document.getElementById('combinedChart');
    if (!chartDiv.data) return;

    let update = {};
    let traceIndices = [];

    switch(traceType) {
        case 'candlestick':
            traceIndices = [0]; // OHLC is always first
            break;
        case 'signals':
            // Find buy/sell signal traces
            chartDiv.data.forEach((trace, idx) => {
                if (trace.name === 'Buy Signals' || trace.name === 'Sell Signals') {
                    traceIndices.push(idx);
                }
            });
            break;
        case 'ma':
            // Find moving average trace
            chartDiv.data.forEach((trace, idx) => {
                if (trace.name && trace.name.includes('Moving Average')) {
                    traceIndices.push(idx);
                }
            });
            break;
        case 'macd':
            // Find MACD traces
            chartDiv.data.forEach((trace, idx) => {
                if (trace.name && (trace.name.includes('MACD') || trace.name === 'MACD Signal')) {
                    traceIndices.push(idx);
                }
            });
            break;
    }

    if (traceIndices.length > 0) {
        const currentVisibility = chartDiv.data[traceIndices[0]].visible;
        const newVisibility = currentVisibility === true ? 'legendonly' : true;
        
        update.visible = traceIndices.map(() => newVisibility);
        Plotly.restyle(chartDiv, update, traceIndices);
    }
}

function toggleFullscreen(wrapperId) {
    const wrapper = document.getElementById(wrapperId);
    const isFullscreen = wrapper.classList.contains('fullscreen');
    
    if (!isFullscreen) {
        wrapper.classList.add('fullscreen');
        
        // Add escape key listener
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                wrapper.classList.remove('fullscreen');
                document.removeEventListener('keydown', escHandler);
                
                // Resize chart after exiting fullscreen
                setTimeout(() => {
                    Plotly.Plots.resize('combinedChart');
                }, 300);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        // Update fullscreen button text
        const btn = wrapper.querySelector('.fullscreen-btn');
        btn.innerHTML = '<i class="fas fa-compress"></i> Exit Fullscreen';
        
        // Resize chart for fullscreen
        setTimeout(() => {
            Plotly.Plots.resize('combinedChart');
        }, 300);
    } else {
        wrapper.classList.remove('fullscreen');
        
        // Reset button text
        const btn = wrapper.querySelector('.fullscreen-btn');
        btn.innerHTML = '<i class="fas fa-expand"></i> Fullscreen';
    }
}

// Load charts on page load if there's only one backtest
document.addEventListener('DOMContentLoaded', function() {
    const backtestSelect = document.getElementById('backtestSelect');
    if (backtestSelect.options.length === 2) { // Only default option + 1 backtest
        backtestSelect.selectedIndex = 1;
        loadCharts();
    } else if (backtestSelect.options.length === 1) {
        document.getElementById('noDataMessage').style.display = 'block';
    }
});

// Handle window resize
window.addEventListener('resize', function() {
    setTimeout(() => {
        if (currentChartData) {
            Plotly.Plots.resize('combinedChart');
        }
    }, 100);
});
</script>
{% endblock %}
